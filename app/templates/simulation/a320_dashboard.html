{% extends "base.html" %}

{% block title %}{{ title | default('A320 Wing System Analysis Dashboard') }}{% endblock %}

{% block head %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/simulation.css') }}">
<style>
  /* Dashboard specific styles */
  .dashboard-container {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    grid-template-rows: auto auto;
    gap: var(--spacing-6);
    width: 100%;
    max-width: var(--container-width);
    margin: 0 auto var(--spacing-8);
  }
  
  .dashboard-card {
    background-color: var(--bg-secondary);
    border-radius: var(--radius-lg);
    padding: var(--spacing-4);
    box-shadow: var(--shadow-md);
    display: flex;
    flex-direction: column;
  }
  
  .dashboard-card-header {
    margin-bottom: var(--spacing-4);
    padding-bottom: var(--spacing-2);
    border-bottom: 1px solid var(--border-color);
  }
  
  .dashboard-card-header h3 {
    width: 100%;
    margin: 0 0 var(--spacing-1) 0;
    font-size: 1.2rem;
  }
  
  .dashboard-card-header p {
    width: 100%;
    margin: 0;
    font-size: 0.9rem;
    color: var(--text-tertiary);
  }
  
  .dashboard-card-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: relative;
  }
  
  .dashboard-card-content img {
    max-width: 100%;
    height: auto;
    border-radius: var(--radius-md);
  }
  
  .dashboard-controls {
    grid-column: span 2;
    background-color: var(--bg-secondary);
    border-radius: var(--radius-lg);
    padding: var(--spacing-4);
    box-shadow: var(--shadow-md);
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-4);
  }
  
  .control-panel {
    flex: 1;
    min-width: 200px;
  }
  
  .control-panel h3 {
    margin: 0 0 var(--spacing-2) 0;
    font-size: 1.1rem;
    width: 100%;
    padding-bottom: var(--spacing-2);
    border-bottom: 1px solid var(--border-color);
  }
  
  .control-group {
    margin-bottom: var(--spacing-3);
  }
  
  .dashboard-data {
    grid-column: span 2;
    display: flex;
    flex-wrap: wrap;
    gap: var(--spacing-4);
  }
  
  .data-card {
    flex: 1;
    min-width: 200px;
    background-color: var(--bg-secondary);
    border-radius: var(--radius-md);
    padding: var(--spacing-3);
    box-shadow: var(--shadow-sm);
  }
  
  .data-card h4 {
    margin: 0 0 var(--spacing-2) 0;
    font-size: 1rem;
    color: var(--text-tertiary);
    width: 100%;
  }
  
  .data-value {
    font-size: 1.5rem;
    font-weight: bold;
    color: var(--text-primary);
  }
  
  .positive-trend {
    color: #4cd964;
  }
  
  .negative-trend {
    color: #ff3b30;
  }
  
  .neutral-trend {
    color: var(--text-primary);
  }
  
  /* CFD 시각화 관련 스타일 */
  .cfd-container {
    width: 100%;
    height: 100%;
    position: relative;
    min-height: 400px;
  }
  
  #cfdCanvas {
    width: 100%;
    height: 100%;
    border-radius: var(--radius-md);
  }
  
  .data-overlay {
    position: absolute;
    top: 10px;
    left: 10px;
    background-color: rgba(0,0,0,0.7);
    color: white;
    padding: 10px;
    border-radius: 5px;
    font-family: monospace;
    font-size: 12px;
    z-index: 10;
  }
  
  .color-legend {
    display: flex;
    margin-top: var(--spacing-2);
    align-items: center;
    width: 100%;
  }
  
  .color-bar {
    height: 20px;
    flex-grow: 1;
    background: linear-gradient(to right, blue, cyan, green, yellow, red);
    margin: 0 var(--spacing-2);
    border-radius: 2px;
  }
  
  .config-settings {
    display: flex;
    gap: var(--spacing-2);
    margin-top: var(--spacing-2);
    flex-wrap: wrap;
  }
  
  .config-button {
    background-color: var(--bg-tertiary);
    border: 1px solid var(--border-color);
    border-radius: var(--radius-md);
    padding: var(--spacing-1) var(--spacing-3);
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .config-button:hover {
    background-color: var(--bg-accent);
    color: white;
  }
  
  .config-button.active {
    background-color: var(--bg-accent);
    color: white;
  }
  
  .checkbox-option {
    display: flex;
    align-items: center;
    gap: var(--spacing-2);
    margin-bottom: var(--spacing-2);
  }
  
  .control-button {
    background-color: var(--bg-accent);
    color: white;
    border: none;
    border-radius: var(--radius-md);
    padding: var(--spacing-2) var(--spacing-4);
    cursor: pointer;
    transition: all 0.2s ease;
    margin-right: var(--spacing-2);
    margin-bottom: var(--spacing-2);
  }
  
  .control-button:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
  }
  
  .control-button.secondary {
    background-color: var(--bg-tertiary);
    color: var(--text-primary);
  }
  
  @media (max-width: 900px) {
    .dashboard-container {
      grid-template-columns: 1fr;
    }
    
    .dashboard-controls,
    .dashboard-data {
      grid-column: span 1;
    }
  }
</style>
{% endblock %}

{% block content %}
<div class="section-header">
    <h1>{{ title | default('A320 Wing System Analysis Dashboard') }}</h1>
    <p>{{ description | default('Comprehensive analysis of A320 aerodynamics with high-lift devices') }}</p>
</div>

<!-- Main dashboard container -->
<div class="dashboard-container">
    <!-- Controls section -->
    <div class="dashboard-controls">
        <div class="control-panel">
            <h3>Flight Parameters</h3>
            
            <div class="control-group">
                <label for="aoaControl">Angle of Attack: <span id="aoaValue">2.0</span>°</label>
                <input type="range" id="aoaControl" min="-5" max="15" step="0.5" value="2.0">
            </div>
            
            <div class="control-group">
                <label for="machControl">Mach Number: <span id="machValue">0.78</span></label>
                <input type="range" id="machControl" min="0.1" max="0.95" step="0.01" value="0.78">
            </div>
            
            <div class="control-group">
                <label for="altitudeControl">Altitude: <span id="altitudeValue">10000</span> m</label>
                <input type="range" id="altitudeControl" min="0" max="12000" step="100" value="10000">
            </div>
        </div>
        
        <div class="control-panel">
            <h3>High-Lift Devices</h3>
            
            <div class="control-group">
                <label>Flap Setting</label>
                <div class="config-settings" id="flapSettings">
                    <div class="config-button" data-setting="UP">UP</div>
                    <div class="config-button" data-setting="1">1</div>
                    <div class="config-button active" data-setting="2">2</div>
                    <div class="config-button" data-setting="3">3</div>
                    <div class="config-button" data-setting="FULL">FULL</div>
                </div>
            </div>
            
            <div class="control-group">
                <label>Slat Setting</label>
                <div class="config-settings" id="slatSettings">
                    <div class="config-button" data-setting="UP">UP</div>
                    <div class="config-button" data-setting="MID">MID</div>
                    <div class="config-button active" data-setting="2">2</div>
                    <div class="config-button" data-setting="3">FULL</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="spoilerControl">Spoiler Deflection: <span id="spoilerValue">0</span>°</label>
                <input type="range" id="spoilerControl" min="0" max="50" step="1" value="0">
            </div>
        </div>
        
        <div class="control-panel">
            <h3>Visualization Options</h3>
            
            <div class="control-group">
                <div class="checkbox-option">
                    <input type="checkbox" id="showVelocity" checked>
                    <label for="showVelocity">Show Velocity Vectors</label>
                </div>
                <div class="checkbox-option">
                    <input type="checkbox" id="showPressure" checked>
                    <label for="showPressure">Show Pressure Field</label>
                </div>
            </div>
            
            <div class="control-group">
                <button id="updateData" class="control-button">
                    <i class="fas fa-sync"></i> Update Analysis
                </button>
                
                <button id="resetConfig" class="control-button secondary">
                    <i class="fas fa-undo"></i> Reset Simulation
                </button>
                
                <button id="exportData" class="control-button secondary">
                    <i class="fas fa-download"></i> Export Data
                </button>
            </div>
        </div>
    </div>
    
    <!-- Key performance metrics -->
    <div class="dashboard-data">
        <div class="data-card">
            <h4>Lift Coefficient (CL)</h4>
            <div class="data-value" id="liftCoefficient">0.582</div>
            <div class="data-trend positive-trend" id="liftTrend">+2.3%</div>
        </div>
        
        <div class="data-card">
            <h4>Drag Coefficient (CD)</h4>
            <div class="data-value" id="dragCoefficient">0.0214</div>
            <div class="data-trend negative-trend" id="dragTrend">+4.8%</div>
        </div>
        
        <div class="data-card">
            <h4>Lift-to-Drag Ratio</h4>
            <div class="data-value" id="ldRatio">27.2</div>
            <div class="data-trend neutral-trend" id="ldTrend">-2.3%</div>
        </div>
        
        <div class="data-card">
            <h4>Critical Mach Number</h4>
            <div class="data-value" id="criticalMach">0.83</div>
            <div class="data-trend positive-trend" id="machTrend">+5.1%</div>
        </div>
    </div>
    
    <!-- CFD Visualization (main feature) -->
    <div class="dashboard-card" style="grid-column: span 2;">
        <div class="dashboard-card-header">
            <h3>CFD Flow Visualization</h3>
            <p>Real-time simulation of airflow and pressure distribution around A320 airfoil</p>
        </div>
        <div class="dashboard-card-content">
            <div class="cfd-container">
                <canvas id="cfdCanvas"></canvas>
                <div class="data-overlay">
                    <div>dt: <span id="timeStep">1.80e-03</span> s</div>
                    <div>max(CFL): <span id="cflValue">0.20</span></div>
                    <div>CPU: <span id="cpuTime">23</span> ms</div>
                    <div>Steps: <span id="stepCount">0</span></div>
                </div>
            </div>
            <div class="color-legend">
                <span>Low Pressure</span>
                <div class="color-bar"></div>
                <span>High Pressure</span>
            </div>
        </div>
    </div>
    
    <!-- Airfoil plot -->
    <div class="dashboard-card">
        <div class="dashboard-card-header">
            <h3>Airfoil Geometry</h3>
            <p>A320 wing section with current high-lift device configuration</p>
        </div>
        <div class="dashboard-card-content">
            <img id="airfoilPlot" src="{{ url_for('visualization.get_visualization', plot_type='airfoil') }}" 
                 alt="A320 Airfoil Geometry">
        </div>
    </div>
    
    <!-- Pressure distribution plot -->
    <div class="dashboard-card">
        <div class="dashboard-card-header">
            <h3>Pressure Distribution</h3>
            <p>Surface pressure coefficient around the airfoil</p>
        </div>
        <div class="dashboard-card-content">
            <img id="pressurePlot" src="{{ url_for('visualization.get_visualization', plot_type='pressure') }}" 
                 alt="Pressure Distribution">
        </div>
    </div>
</div>

<!-- Navigation links -->
<div class="simulation-navigation">
    <a href="{{ url_for('simulation.a320_simulation') }}" class="btn btn-secondary">
        <i class="fas fa-arrow-left"></i> Back to Simulation
    </a>
    
    <a href="{{ url_for('simulation.index') }}" class="btn btn-secondary">
        <i class="fas fa-th"></i> All Simulations
    </a>
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // 기존 A320 컨트롤 Elements
    const aoaControl = document.getElementById('aoaControl');
    const aoaValue = document.getElementById('aoaValue');
    const machControl = document.getElementById('machControl');
    const machValue = document.getElementById('machValue');
    const altitudeControl = document.getElementById('altitudeControl');
    const altitudeValue = document.getElementById('altitudeValue');
    const spoilerControl = document.getElementById('spoilerControl');
    const spoilerValue = document.getElementById('spoilerValue');
    const flapButtons = document.querySelectorAll('#flapSettings .config-button');
    const slatButtons = document.querySelectorAll('#slatSettings .config-button');
    const updateButton = document.getElementById('updateData');
    const resetButton = document.getElementById('resetConfig');
    const exportButton = document.getElementById('exportData');
    
    // 시각화 옵션 Elements
    const showVelocityCheckbox = document.getElementById('showVelocity');
    const showPressureCheckbox = document.getElementById('showPressure');
    
    // Plot images
    const airfoilPlot = document.getElementById('airfoilPlot');
    const pressurePlot = document.getElementById('pressurePlot');
    
    // Current configuration
    let currentConfig = {
        aoa: 2.0,
        mach: 0.78,
        altitude: 10000,
        flap: '2',
        slat: '2',
        spoiler: 0,
        showVelocity: true,
        showPressure: true
    };
    
    // ---- CFD 시뮬레이션 관련 코드 ----
    const canvas = document.getElementById('cfdCanvas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    // CFD 시뮬레이션 상태
    const cfdSimulation = {
        initialized: false,
        running: false,
        stepCount: 0,
        timeStep: 0.0018,
        cfl: 0.2,
        
        // 격자 및 유동장 데이터
        gridSize: 50,
        pressureField: [],
        velocityField: []
    };
    
    // 캔버스 크기 설정
    function resizeCanvas() {
        const container = canvas.parentElement;
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        
        // 크기 변경 시 다시 그리기
        if (cfdSimulation.initialized) {
            drawCFDSimulation();
        }
    }
    
    // 초기 크기 설정 및 리사이즈 이벤트 리스너 추가
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // 압력값을 색상으로 변환
    function getPressureColor(pressure) {
        if (pressure === null) return '#666'; // 물체는 회색으로 표시
        
        // 압력 범위 계산 (-1.0 ~ 2.0)
        const normalizedPressure = (pressure + 1.0) / 3.0;
        
        // 색상 그라데이션 (청색-청록-녹색-황색-적색)
        if (normalizedPressure < 0.25) {
            // 청색에서 청록색으로
            const t = normalizedPressure * 4;
            return `rgb(0, ${Math.round(255 * t)}, 255)`;
        } else if (normalizedPressure < 0.5) {
            // 청록색에서 녹색으로
            const t = (normalizedPressure - 0.25) * 4;
            return `rgb(0, 255, ${Math.round(255 * (1 - t))})`;
        } else if (normalizedPressure < 0.75) {
            // 녹색에서 황색으로
            const t = (normalizedPressure - 0.5) * 4;
            return `rgb(${Math.round(255 * t)}, 255, 0)`;
        } else {
            // 황색에서 적색으로
            const t = (normalizedPressure - 0.75) * 4;
            return `rgb(255, ${Math.round(255 * (1 - t))}, 0)`;
        }
    }
    
    // 오버레이 데이터 업데이트
    function updateOverlay() {
        document.getElementById('timeStep').textContent = cfdSimulation.timeStep.toExponential(2);
        document.getElementById('cflValue').textContent = cfdSimulation.cfl.toFixed(2);
        document.getElementById('cpuTime').textContent = (Math.random() * 10 + 20).toFixed(0);
        document.getElementById('stepCount').textContent = cfdSimulation.stepCount;
    }
    
    // CFD 시뮬레이션 그리기
    function drawCFDSimulation() {
        if (!cfdSimulation.initialized) return;
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const rows = cfdSimulation.pressureField.length;
        const cols = cfdSimulation.pressureField[0].length;
        const cellWidth = canvas.width / cols;
        const cellHeight = canvas.height / rows;
        
        // 압력장 그리기
        if (currentConfig.showPressure) {
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const pressure = cfdSimulation.pressureField[i][j];
                    ctx.fillStyle = getPressureColor(pressure);
                    ctx.fillRect(j * cellWidth, i * cellHeight, cellWidth, cellHeight);
                }
            }
        } else {
            // 압력장 없이 물체만 표시
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (cfdSimulation.pressureField[i][j] === null) {
                        ctx.fillStyle = '#666';
                        ctx.fillRect(j * cellWidth, i * cellHeight, cellWidth, cellHeight);
                    }
                }
            }
            
            // 배경색 설정
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // 속도 벡터 그리기
        if (currentConfig.showVelocity) {
            ctx.lineWidth = 1;
            
            // 격자 점마다 벡터 그리기
            const skip = 1; // 모든 격자점 사용
            
            for (let i = 0; i < rows; i += skip) {
                for (let j = 0; j < cols; j += skip) {
                    const velocity = cfdSimulation.velocityField[i][j];
                    
                    // 물체 내부는 건너뜀
                    if (velocity === null) continue;
                    
                    const x = j * cellWidth;
                    const y = i * cellHeight;
                    
                    // 속도 크기 계산
                    const speed = Math.sqrt(velocity.vx * velocity.vx + velocity.vy * velocity.vy);
                    const maxSpeed = currentConfig.mach * 340 * 1.5;
                    const normalizedSpeed = Math.min(speed / maxSpeed, 1.0);
                    
                    // 벡터 길이 계산
                    const vectorLength = normalizedSpeed * cellWidth * 1.2;
                    
                    // 벡터 종점 계산
                    const endX = x + velocity.vx / speed * vectorLength;
                    const endY = y + velocity.vy / speed * vectorLength;
                    
                    // 벡터 그리기
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(endX, endY);
                    
                    // 벡터 색상 (흰색에서 검정색까지)
                    const brightness = Math.round(255 * (1 - normalizedSpeed * 0.8));
                    ctx.strokeStyle = `rgb(${brightness}, ${brightness}, ${brightness})`;
                    
                    ctx.stroke();
                    
                    // 화살표 머리 그리기
                    const arrowSize = 3;
                    const angle = Math.atan2(endY - y, endX - x);
                    
                    ctx.beginPath();
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(
                        endX - arrowSize * Math.cos(angle - Math.PI / 6),
                        endY - arrowSize * Math.sin(angle - Math.PI / 6)
                    );
                    ctx.moveTo(endX, endY);
                    ctx.lineTo(
                        endX - arrowSize * Math.cos(angle + Math.PI / 6),
                        endY - arrowSize * Math.sin(angle + Math.PI / 6)
                    );
                    ctx.stroke();
                }
            }
        }
    }
    
    // A320 에어포일 형상 생성
    function generateAirfoilShape(centerX, centerY, chordLength, rows, cols) {
        // 기본 두께 및 캠버 비율
        const thicknessRatio = 0.12; // 12% 두께
        const camberRatio = 0.02; // 2% 캠버
        
        // 기본 에어포일 형상 (x, y 좌표 배열)
        const baseAirfoil = [];
        
        // 상부 표면 좌표 생성
        for (let xRatio = 0; xRatio <= 1; xRatio += 0.01) {
            // NACA 4-digit 형상 근사화
            const thickness = 5 * thicknessRatio * (0.2969 * Math.sqrt(xRatio) - 0.1260 * xRatio - 
                            0.3516 * xRatio**2 + 0.2843 * xRatio**3 - 0.1015 * xRatio**4);
            
            // 캠버 계산
            let camber;
            if (xRatio < 0.4) { // 최대 캠버 위치 = 0.4c
                camber = camberRatio * (xRatio / 0.4) * (2 - xRatio / 0.4);
            } else {
                camber = camberRatio * ((1 - xRatio) / 0.6) * (1 + xRatio / 0.6);
            }
            
            // 상부 표면 (x, y) - 캠버 추가
            baseAirfoil.push({
                x: xRatio,
                y: camber + thickness,
                surface: 'upper'
            });
        }
        
        // 하부 표면 좌표 생성 (역순으로)
        for (let xRatio = 1; xRatio >= 0; xRatio -= 0.01) {
            const thickness = 5 * thicknessRatio * (0.2969 * Math.sqrt(xRatio) - 0.1260 * xRatio - 
                            0.3516 * xRatio**2 + 0.2843 * xRatio**3 - 0.1015 * xRatio**4);
            
            // 캠버 계산
            let camber;
            if (xRatio < 0.4) {
                camber = camberRatio * (xRatio / 0.4) * (2 - xRatio / 0.4);
            } else {
                camber = camberRatio * ((1 - xRatio) / 0.6) * (1 + xRatio / 0.6);
            }
            
            // 하부 표면 (x, y) - 캠버 추가
            baseAirfoil.push({
                x: xRatio,
                y: camber - thickness,
                surface: 'lower'
            });
        }
        
        // 계산된 에어포일 좌표를 실제 격자에 매핑
        for (const point of baseAirfoil) {
            // 좌표 변환 (에어포일 좌표 → 격자 좌표)
            const gridX = Math.floor(centerX + point.x * chordLength);
            const gridY = Math.floor(centerY + point.y * chordLength * 0.5); // Y 방향은 압축
            
            // 유효한 격자 범위 확인
            if (gridY >= 0 && gridY < rows && gridX >= 0 && gridX < cols) {
                // 해당 격자 위치에 에어포일 표시 (압력장과 속도장을 null로 설정)
                cfdSimulation.pressureField[gridY][gridX] = null;
                cfdSimulation.velocityField[gridY][gridX] = null;
            }
        }
        
        // 플랩 형상 (CONF에 따라 다름)
        if (currentConfig.flap !== 'UP') {
            // 플랩 각도 및 위치 결정
            let flapAngle, flapExtension;
            
            switch (currentConfig.flap) {
                case '1': 
                    flapAngle = 10;
                    flapExtension = 0.02;
                    break;
                case '2': 
                    flapAngle = 15;
                    flapExtension = 0.035;
                    break;
                case '3': 
                    flapAngle = 20;
                    flapExtension = 0.05;
                    break;
                case 'FULL': 
                    flapAngle = 35;
                    flapExtension = 0.08;
                    break;
                default:
                    flapAngle = 0;
                    flapExtension = 0;
            }
            
            // 플랩 위치 계산 (후방 70%부터 시작)
            const flapStartX = centerX + 0.7 * chordLength;
            
            if (flapAngle > 0) {
                // 플랩 길이 및 두께
                const flapLength = 0.3 * chordLength; // 플랩은 코드의 30%
                const flapThickness = 0.08 * chordLength; // 플랩 두께
                
                // 각도를 라디안으로 변환
                const angleRad = flapAngle * Math.PI / 180;
                
                // 플랩 확장 거리
                const extensionX = flapExtension * chordLength;
                const extensionY = 0.01 * chordLength; // 약간 아래로
                
                // 플랩 형상 생성
                for (let i = 0; i < flapLength; i++) {
                   // 플랩 두께 분포 (뒤로 갈수록 얇아짐)
                   const localThickness = flapThickness * (1 - localX * 0.5);
                    
                    // 회전 및 확장 적용
                    const rotatedX = Math.cos(angleRad) * i - Math.sin(angleRad) * 0;
                    const rotatedYupper = Math.sin(angleRad) * i + Math.cos(angleRad) * (localThickness / 2);
                    const rotatedYlower = Math.sin(angleRad) * i + Math.cos(angleRad) * (-localThickness / 2);
                    
                    // 격자 좌표로 변환
                    const gridFlapX = Math.floor(flapStartX + extensionX + rotatedX);
                    const gridFlapYupper = Math.floor(centerY + extensionY + rotatedYupper);
                    const gridFlapYlower = Math.floor(centerY + extensionY + rotatedYlower);
                    
                    // 플랩 표면 마킹
                    for (let y = gridFlapYlower; y <= gridFlapYupper; y++) {
                        if (y >= 0 && y < rows && gridFlapX >= 0 && gridFlapX < cols) {
                            cfdSimulation.pressureField[y][gridFlapX] = null;
                            cfdSimulation.velocityField[y][gridFlapX] = null;
                        }
                    }
                }
            }
        }
        
        // 슬랫 형상 (설정에 따라 다름)
        if (currentConfig.slat !== 'UP') {
            // 슬랫 확장 정도 및 각도 결정
            let slatExtension, slatAngle;
            
            switch (currentConfig.slat) {
                case 'MID': 
                    slatExtension = 0.018;
                    slatAngle = 13;
                    break;
                case '1': 
                    slatExtension = 0.022;
                    slatAngle = 16;
                    break;
                case '2': 
                    slatExtension = 0.024;
                    slatAngle = 18;
                    break;
                case '3': 
                    slatExtension = 0.027;
                    slatAngle = 20;
                    break;
                default:
                    slatExtension = 0;
                    slatAngle = 0;
            }
            
            // 슬랫 위치 계산 (앞부분 15%까지)
            const slatLength = 0.15 * chordLength;
            
            if (slatExtension > 0) {
                // 슬랫 두께
                const slatThickness = 0.08 * chordLength;
                
                // 각도를 라디안으로 변환
                const angleRad = -slatAngle * Math.PI / 180; // 음수 = 아래로 회전
                
                // 슬랫 확장 거리
                const extensionX = -slatExtension * chordLength; // 앞으로 확장
                const extensionY = 0.01 * chordLength; // 약간 아래로
                
                // 슬랫 형상 생성
                for (let i = 0; i < slatLength; i++) {
                    const localX = i / slatLength; // 0에서 1 사이 값
                    
                    // 슬랫 두께 분포
                    const localThickness = slatThickness * (1 - localX * 0.7);
                    
                    // 회전 및 확장 적용
                    const rotatedX = Math.cos(angleRad) * i - Math.sin(angleRad) * 0;
                    const rotatedYupper = Math.sin(angleRad) * i + Math.cos(angleRad) * (localThickness / 2);
                    const rotatedYlower = Math.sin(angleRad) * i + Math.cos(angleRad) * (-localThickness / 2);
                    
                    // 격자 좌표로 변환
                    const gridSlatX = Math.floor(centerX + extensionX + rotatedX);
                    const gridSlatYupper = Math.floor(centerY + extensionY + rotatedYupper);
                    const gridSlatYlower = Math.floor(centerY + extensionY + rotatedYlower);
                    
                    // 슬랫 표면 마킹
                    for (let y = gridSlatYlower; y <= gridSlatYupper; y++) {
                        if (y >= 0 && y < rows && gridSlatX >= 0 && gridSlatX < cols) {
                            cfdSimulation.pressureField[y][gridSlatX] = null;
                            cfdSimulation.velocityField[y][gridSlatX] = null;
                        }
                    }
                }
            }
        }
        
        // 스포일러 형상 (각도에 따라 다름)
        if (currentConfig.spoiler > 0) {
            // 스포일러 위치 (날개 상단 중앙부)
            const spoilerStartX = centerX + 0.4 * chordLength;
            const spoilerLength = 0.2 * chordLength;
            
            // 스포일러 각도
            const spoilerAngle = currentConfig.spoiler;
            const spoilerRad = spoilerAngle * Math.PI / 180;
            
            // 스포일러 높이 계산 (각도에 비례)
            const maxHeight = 0.1 * chordLength * (spoilerAngle / 50);
            
            // 스포일러 형상 생성
            for (let i = 0; i < spoilerLength; i++) {
                const localX = i / spoilerLength;
                const height = maxHeight * Math.sin(Math.PI * localX);
                
                // 회전된 좌표 계산
                const rotatedX = Math.cos(spoilerRad) * i;
                const rotatedY = -Math.sin(spoilerRad) * i - height; // 상단에 위치
                
                // 격자 좌표로 변환
                const gridSpoilerX = Math.floor(spoilerStartX + rotatedX);
                const gridSpoilerY = Math.floor(centerY + rotatedY);
                
                // 유효한 격자 범위 확인
                if (gridSpoilerY >= 0 && gridSpoilerY < rows && gridSpoilerX >= 0 && gridSpoilerX < cols) {
                    cfdSimulation.pressureField[gridSpoilerY][gridSpoilerX] = null;
                    cfdSimulation.velocityField[gridSpoilerY][gridSpoilerX] = null;
                }
            }
        }
    }
    
    // CFD 시뮬레이션 계산 (간단한 유동 모델)
    function calculateCFDSimulation() {
        if (!cfdSimulation.initialized) return;
        
        const rows = cfdSimulation.pressureField.length;
        const cols = cfdSimulation.pressureField[0].length;
        
        // 시뮬레이션 매개변수 업데이트 (현재 설정 기반)
        const aoaRad = currentConfig.aoa * Math.PI / 180;
        const baseVx = currentConfig.mach * 340 * Math.cos(aoaRad);
        const baseVy = currentConfig.mach * 340 * Math.sin(aoaRad);
        
        // 압력장 업데이트 (라플라스 방정식 근사)
        for (let i = 1; i < rows - 1; i++) {
            for (let j = 1; j < cols - 1; j++) {
                // 물체 내부는 건너뜀
                if (cfdSimulation.pressureField[i][j] === null) continue;
                
                // 주변 압력값의 평균으로 업데이트 (라플라스 방정식의 간단한 근사)
                let sum = 0;
                let count = 0;
                
                const neighbors = [
                    [i-1, j], [i+1, j], [i, j-1], [i, j+1]
                ];
                
                for (const [ni, nj] of neighbors) {
                    if (ni >= 0 && ni < rows && nj >= 0 && nj < cols && 
                        cfdSimulation.pressureField[ni][nj] !== null) {
                        sum += cfdSimulation.pressureField[ni][nj];
                        count++;
                    }
                }
                
                if (count > 0) {
                    cfdSimulation.pressureField[i][j] = 0.9 * cfdSimulation.pressureField[i][j] + 0.1 * (sum / count);
                }
            }
        }
        
        // 유입 경계 조건 (왼쪽 경계)
        for (let i = 0; i < rows; i++) {
            // 압력 구배 0
            cfdSimulation.pressureField[i][0] = cfdSimulation.pressureField[i][1];
            
            // 속도 고정
            cfdSimulation.velocityField[i][0] = {
                vx: baseVx,
                vy: baseVy
            };
        }
        
        // 물체 주변에 압력 생성
        const centerX = Math.floor(cols * 0.3);
        const centerY = Math.floor(rows * 0.5);
        
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                // 물체 바로 주변 셀 찾기
                if (cfdSimulation.pressureField[i][j] !== null) {
                    // 인접한 셀이 물체인지 확인
                    const neighbors = [
                        [i-1, j], [i+1, j], [i, j-1], [i, j+1]
                    ];
                    
                    let isNearObject = false;
                    for (const [ni, nj] of neighbors) {
                        if (ni >= 0 && ni < rows && nj >= 0 && nj < cols && 
                            cfdSimulation.pressureField[ni][nj] === null) {
                            isNearObject = true;
                            break;
                        }
                    }
                    
                    if (isNearObject) {
                        // 물체 앞쪽에는 높은 압력
                        if (j < centerX) {
                            cfdSimulation.pressureField[i][j] = Math.max(cfdSimulation.pressureField[i][j], 1.5);
                        }
                        // 물체 뒤쪽에는 낮은 압력
                        else if (j > centerX) {
                            cfdSimulation.pressureField[i][j] = Math.min(cfdSimulation.pressureField[i][j], -0.5);
                        }
                    }
                }
            }
        }
        
        // 속도장 계산 (압력 구배에 따라)
        for (let i = 1; i < rows - 1; i++) {
            for (let j = 1; j < cols - 1; j++) {
                // 물체 내부는 건너뜀
                if (cfdSimulation.velocityField[i][j] === null) continue;
                
                // 압력 구배 계산
                const dp_dx = (cfdSimulation.pressureField[i][j+1] !== null ? cfdSimulation.pressureField[i][j+1] : 0) - 
                              (cfdSimulation.pressureField[i][j-1] !== null ? cfdSimulation.pressureField[i][j-1] : 0);
                const dp_dy = (cfdSimulation.pressureField[i+1][j] !== null ? cfdSimulation.pressureField[i+1][j] : 0) - 
                              (cfdSimulation.pressureField[i-1][j] !== null ? cfdSimulation.pressureField[i-1][j] : 0);
                
                // 속도 업데이트 (압력 구배의 영향을 받음)
                let vx = cfdSimulation.velocityField[i][j].vx - dp_dx * 0.1;
                let vy = cfdSimulation.velocityField[i][j].vy - dp_dy * 0.1;
                
                // 관성항 (이전 속도의 영향)
                vx = 0.9 * vx + 0.1 * baseVx;
                vy = 0.9 * vy + 0.1 * baseVy;
                
                // 물체 주변에서 속도 조정 (더 사실적인 유동을 위해)
                for (let di = -1; di <= 1; di++) {
                    for (let dj = -1; dj <= 1; dj++) {
                        const ni = i + di;
                        const nj = j + dj;
                        if (ni >= 0 && ni < rows && nj >= 0 && nj < cols && 
                            cfdSimulation.velocityField[ni][nj] === null) {
                            // 물체에 가까울수록 속도가 변함
                            const dist = Math.sqrt(di*di + dj*dj);
                            const effect = 1 / (dist + 0.1);
                            
                            // 물체 주위로 흐르는 효과
                            if (j < centerX) {  // 물체 앞쪽
                                // 위/아래로 흐름 유도
                                if (i < centerY) vy -= effect * 0.5;
                                else vy += effect * 0.5;
                            } else {  // 물체 뒤쪽
                                // 후류 효과
                                vx *= 0.9;
                                if (Math.random() < 0.05) {
                                    // 랜덤한 요동 추가
                                    vy += (Math.random() - 0.5) * 0.5;
                                }
                            }
                        }
                    }
                }
                
                cfdSimulation.velocityField[i][j] = { vx, vy };
            }
        }
        
        // 시뮬레이션 스텝 증가
        cfdSimulation.stepCount++;
        updateOverlay();
    }
    
    // CFD 시뮬레이션 초기화
    function initCFDSimulation() {
        cfdSimulation.stepCount = 0;
        updateOverlay();
        
        // 격자 크기에 맞게 압력장과 속도장 초기화
        const rows = Math.ceil(canvas.height / cfdSimulation.gridSize);
        const cols = Math.ceil(canvas.width / cfdSimulation.gridSize);
        
        cfdSimulation.pressureField = new Array(rows);
        cfdSimulation.velocityField = new Array(rows);
        
        for (let i = 0; i < rows; i++) {
            cfdSimulation.pressureField[i] = new Array(cols);
            cfdSimulation.velocityField[i] = new Array(cols);
            
            for (let j = 0; j < cols; j++) {
                // 초기 압력은 0으로 설정
                cfdSimulation.pressureField[i][j] = 0;
                
                // 초기 속도는 입구 속도와 받음각에 따라 설정
                const angleRad = currentConfig.aoa * Math.PI / 180;
                const vx = currentConfig.mach * 340 * Math.cos(angleRad);
                const vy = currentConfig.mach * 340 * Math.sin(angleRad);
                
                cfdSimulation.velocityField[i][j] = { vx, vy };
            }
        }
        
        // 날개 형상 정의 (A320 에어포일 기반)
        const centerX = Math.floor(cols * 0.3);
        const centerY = Math.floor(rows * 0.5);
        const chordLength = Math.floor(cols * 0.4);
        
        // 날개 형상 결정 (플랩 및 슬랫 설정에 따라 조정 가능)
        generateAirfoilShape(centerX, centerY, chordLength, rows, cols);
        
        cfdSimulation.initialized = true;
        
        // 초기 시뮬레이션 계산 및 그리기
        calculateCFDSimulation();
        drawCFDSimulation();
    }
    
    // CFD 시뮬레이션 업데이트
    function updateCFDSimulation() {
        if (!cfdSimulation.initialized) {
            initCFDSimulation();
            return;
        }
        
        // 시뮬레이션 계산 및 그리기
        calculateCFDSimulation();
        drawCFDSimulation();
    }
    
    // Update plot URLs with current parameters
    function updatePlots() {
        const baseUrl = window.location.origin;
        
        // Update URLs with current configuration
        airfoilPlot.src = `${baseUrl}/visualization/a320/airfoil?aoa=${currentConfig.aoa}&flap=${currentConfig.flap}&slat=${currentConfig.slat}&_=${Date.now()}`;
        pressurePlot.src = `${baseUrl}/visualization/a320/pressure?aoa=${currentConfig.aoa}&mach=${currentConfig.mach}&flap=${currentConfig.flap}&slat=${currentConfig.slat}&_=${Date.now()}`;
        
        // Fetch updated data
        fetchData();
        
        // 또한 CFD 시뮬레이션도 업데이트
        updateCFDSimulation();
    }
    
    // Fetch aerodynamic data
    function fetchData() {
        const baseUrl = window.location.origin;
        fetch(`${baseUrl}/visualization/a320/data?aoa=${currentConfig.aoa}&mach=${currentConfig.mach}&flap=${currentConfig.flap}&slat=${currentConfig.slat}`)
            .then(response => response.json())
            .then(data => {
                // Update displayed values
                document.getElementById('liftCoefficient').textContent = data.current_state.lift_coefficient.toFixed(3);
                document.getElementById('dragCoefficient').textContent = data.current_state.drag_coefficient.toFixed(4);
                
                // Calculate L/D ratio
                const ldRatio = data.current_state.lift_coefficient / data.current_state.drag_coefficient;
                document.getElementById('ldRatio').textContent = ldRatio.toFixed(1);
                
                // Update other data as needed
                // ...
            })
            .catch(error => {
                console.error('Error fetching data:', error);
            });
    }
    
    // 애니메이션 루프
    function animateCFDSimulation() {
        updateCFDSimulation();
        requestAnimationFrame(animateCFDSimulation);
    }
    
    // Control event handlers
    aoaControl.addEventListener('input', function(e) {
        const value = parseFloat(e.target.value);
        aoaValue.textContent = value.toFixed(1);
        currentConfig.aoa = value;
        updatePlots();
    });
    
    machControl.addEventListener('input', function(e) {
        const value = parseFloat(e.target.value);
        machValue.textContent = value.toFixed(2);
        currentConfig.mach = value;
        updatePlots();
    });
    
    altitudeControl.addEventListener('input', function(e) {
        const value = parseInt(e.target.value);
        altitudeValue.textContent = value;
        currentConfig.altitude = value;
        updatePlots();
    });
    
    spoilerControl.addEventListener('input', function(e) {
        const value = parseInt(e.target.value);
        spoilerValue.textContent = value;
        currentConfig.spoiler = value;
        updatePlots();
    });
    
    // Flap settings
    flapButtons.forEach(button => {
        button.addEventListener('click', function() {
            // Update active button
            flapButtons.forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
            
            // Update configuration
            currentConfig.flap = this.dataset.setting;
            updatePlots();
        });
    });
    
    // Slat settings
    slatButtons.forEach(button => {
        button.addEventListener('click', function() {
            // Update active button
            slatButtons.forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
            
            // Update configuration
            currentConfig.slat = this.dataset.setting;
            updatePlots();
        });
    });
    
    // Visualization options
    if (showVelocityCheckbox) {
        showVelocityCheckbox.addEventListener('change', function(e) {
            currentConfig.showVelocity = e.target.checked;
            updateCFDSimulation();
        });
    }
    
    if (showPressureCheckbox) {
        showPressureCheckbox.addEventListener('change', function(e) {
            currentConfig.showPressure = e.target.checked;
            updateCFDSimulation();
        });
    }
    
    // Update button
    updateButton.addEventListener('click', function() {
        updatePlots();
    });
    
    // Reset button
    resetButton.addEventListener('click', function() {
        // Reset to default values
        aoaControl.value = 2.0;
        aoaValue.textContent = '2.0';
        machControl.value = 0.78;
        machValue.textContent = '0.78';
        altitudeControl.value = 10000;
        altitudeValue.textContent = '10000';
        spoilerControl.value = 0;
        spoilerValue.textContent = '0';
        
        // Reset flap and slat buttons
        flapButtons.forEach(btn => {
            if (btn.dataset.setting === '2') {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });
        
        slatButtons.forEach(btn => {
            if (btn.dataset.setting === '2') {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });
        
        // Reset checkboxes
        if (showVelocityCheckbox) showVelocityCheckbox.checked = true;
        if (showPressureCheckbox) showPressureCheckbox.checked = true;
        
        // Update configuration
        currentConfig = {
            aoa: 2.0,
            mach: 0.78,
            altitude: 10000,
            flap: '2',
            slat: '2',
            spoiler: 0,
            showVelocity: true,
            showPressure: true
        };
        
        // Reset CFD simulation
        initCFDSimulation();
        
        // Update plots
        updatePlots();
    });
    
    // Export button
    exportButton.addEventListener('click', function() {
        // Generate export data
        const exportData = {
            configuration: currentConfig,
            timestamp: new Date().toISOString(),
            // Add more data as needed
        };
        
        // Create download link
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportData, null, 2));
        const downloadLink = document.createElement('a');
        downloadLink.setAttribute("href", dataStr);
        downloadLink.setAttribute("download", "a320_wing_analysis.json");
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
    });
    
    // 초기화 및 애니메이션 시작
    initCFDSimulation();
    animateCFDSimulation();
    
    // Initial data fetch
    fetchData();
});
</script>
{% endblock %}